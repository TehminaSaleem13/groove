class ProductsController < ApplicationController
  include ProductConcern

  def import_products
    @store = Store.find(params[:id])
    importservice = init_products_import_service(@store)
    @result = importservice.import_products

    render json: @result
  end

  def import_images
    @store = Store.find(params[:id])
    @result = @product_service.import_images(@store)

    render json: @result
  end

  # PS:Where is this used?
  def import_product_details
    # if current_user.can?('import_products')
    #   @store = Store.find(params[:store_id])
    #   @amazon_credentials = AmazonCredentials.where(:store_id => @store.id)

    #   if @amazon_credentials.length > 0
    #     @credential = @amazon_credentials.first

    #     require 'mws-connect'

    #     mws = Mws.connect(
    #       merchant: @credential.merchant_id,
    #       access: ENV['AMAZON_MWS_ACCESS_KEY_ID'],
    #       secret: ENV['AMAZON_MWS_SECRET_ACCESS_KEY']
    #     )
    #     products_api = mws.products.get_matching_products_for_id(:marketplace_id => @credential.marketplace_id,
    #                                                              :id_type => 'SellerSKU', :id_list => ['T-TOOL'])
    #     require 'active_support/core_ext/hash/conversions'
    #     product_hash = Hash.from_xml(products_api.to_s)
    #     # product_hash = from_xml(products_api)
    #     raise
    #     # response = mws.orders.get_matching_product_for_id :id_type=>'SellerSKU', :seller_sku => ["12345678"],
    #     #   :marketplace_id => @credential.marketplace_id
    #     # # response = mws.orders.list_orders :last_updated_after => 2.months.ago,
    #     # #   :order_status => ['Unshipped', 'PartiallyShipped']
    #     # response.products
    #     @products = Product.where(:store_id => params[:store_id])
    #     @products.each do |product|
    #       #import_amazon_product_details(mws, @credential, product.id)
    #     end
    #   end

    # end
  end

  # def requestamazonreport
  #   @amazon_credentials = AmazonCredentials.where(:store_id => params[:id])
  #   @result = Hash.new
  #   @result['status'] = false
  #   if @amazon_credentials.length > 0

  #     @credential = @amazon_credentials.first

  #     mws = MWS.new(:aws_access_key_id => ENV['AMAZON_MWS_ACCESS_KEY_ID'],
  #                   :secret_access_key => ENV['AMAZON_MWS_SECRET_ACCESS_KEY'],
  #                   :seller_id => @credential.merchant_id,
  #                   :marketplace_id => @credential.marketplace_id)

  #     response = mws.reports.request_report :report_type => '_GET_MERCHANT_LISTINGS_DATA_'
  #     @credential.productreport_id = response.report_request_info.report_request_id
  #     @credential.productgenerated_report_id = nil

  #     if @credential.save
  #       @result['status'] = true
  #       @result['requestedreport_id'] = @credential.productreport_id
  #     end

  #   end

  #   respond_to do |format|
  #     format.json { render json: @result }
  #   end
  # end

  # def checkamazonreportstatus
  #   @amazon_credentials = AmazonCredentials.where(:store_id => params[:id])
  #   @result = Hash.new
  #   @result['status'] = false
  #   report_found = false
  #   if @amazon_credentials.length > 0

  #     @credential = @amazon_credentials.first

  #     mws = MWS.new(:aws_access_key_id => ENV['AMAZON_MWS_ACCESS_KEY_ID'],
  #                   :secret_access_key => ENV['AMAZON_MWS_SECRET_ACCESS_KEY'],
  #                   :seller_id => @credential.merchant_id,
  #                   :marketplace_id => @credential.marketplace_id)

  #     @report_list = mws.reports.get_report_request_list
  #     @report_list.report_request_info.each do |report_request|
  #       if report_request.report_request_id == @credential.productreport_id
  #         report_found = true
  #         if report_request.report_processing_status == '_SUBMITTED_'
  #           @result['status'] = true
  #           @result['report_status'] = 'Report has been submitted successfully. '+
  #             'It is still being generated by the server.'
  #         elsif report_request.report_processing_status == '_DONE_'
  #           @result['report_status'] = 'Report is generated successfully.'

  #           @credential.productgenerated_report_id = report_request.generated_report_id
  #           @credential.productgenerated_report_date = report_request.completed_date
  #           if @credential.save
  #             @result['status'] = true
  #             @result['requestedreport_id'] = @credential.productreport_id
  #             @result['generated_report_id'] = report_request.generated_report_id
  #             @result['generated_report_date'] = report_request.completed_date
  #           end
  #         elsif report_request.report_processing_status == '_INPROGRESS_'
  #           @result['status'] = true
  #           @result['report_status'] = 'Report is in progress. It will be ready in few moments.'
  #         else
  #           @result['response'] = report_request
  #           #store generated report id
  #         end
  #       end
  #     end

  #     if !report_found
  #       @result['status'] = true
  #       @result['report_status'] = 'Report is not found. Please check back in few moments.'
  #     end
  #   end

  #   respond_to do |format|
  #     format.json { render json: @result }
  #   end
  # end

  # Get list of products based on limit and offset. It is by default sorted by updated_at field
  # If sort parameter is passed in then the corresponding sort filter will be used to sort the list
  # The expected parameters in params[:sort] are 'updated_at', name', 'sku', 'status', 'barcode', 'location_primary'
  # and quantity. The API supports to provide order of sorting namely ascending or descending. The parameter can be
  # passed in using params[:order] = 'ASC' or params[:order] ='DESC' [Note: Caps letters] By default, if no order is mentioned,
  # then the API considers order to be descending.The API also supports a product status filter.
  # The filter expects one of the following parameters in params[:filter] 'all', 'active', 'inactive', 'new'.
  # If no filter is passed, then the API will default to 'active'
  # if you would like to get Kits, specify params[:is_kit] to 1. it will return product kits and the corresponding skus
  #
  def index
    @products = do_getproducts(params)
    @result = @result.merge({ 'products' => make_products_list(@products),
                              'products_count' => get_products_count()
                            })
    render json: @result
  end

  def create
    @result = Product.create_new_product(@result, current_user)

    render json: @result
  end
  
  def get_report_products
    @products = do_get_report_products(params)
    @result = @result.merge({ 'products' => make_products_list(@products),
                              'products_count' => get_report_products_count()
                            })
    render json: @result
  end

  def update_inventory_report
    @result = add_inventory_report_products(params)
    render json: @result
  end

  def remove_inventory_report_products
    @result = remove_report_products(params)
    render json: @result
  end

  #This method will generate pdf for receiving inventory label, upload to S3 and return result as url of uploaded file
  def print_receiving_label
    params[:tenant] =  Apartment::Tenant.current
    scan_pack_object = ScanPack::Base.new
    if (params["productArray"].count > 20 || params["select_all"] == true)
      val = scan_pack_object.delay(priority: 95).print_label_with_delay(params)
      render json: {}
    else
      url = scan_pack_object.print_label_with_delay(params)
      render json: {url: url}
    end
  end

  def print_product_barcode_label
    execute_groove_bulk_action('product_barcode_label')
  end

  def generate_barcode
    export_product = ExportSsProductsCsv.new
    data = {}
    data[:result] = @result
    tenant_name = Apartment::Tenant.current
    if (params["productArray"].count > 20 || params["select_all"] == true)
      export_product.delay(priority: 95).generate_barcode_with_delay(params, data, tenant_name)
    else
      export_product.generate_barcode_with_delay(params, data, tenant_name)
    end  
    render json: @result
  end

  def generate_numeric_barcode  
    data = {}
    data[:result] = @result
    tenant_name = Apartment::Tenant.current
    if (params["productArray"].count > 20 || params["select_all"] == true)
      export_product = ExportSsProductsCsv.new
      export_product.delay.generate_numeric_barcode_with_delay(params, data, tenant_name)
    else
      export_product = ExportSsProductsCsv.new
      export_product.generate_numeric_barcode_with_delay(params, data, tenant_name)
    end
    render json: @result 
  end

  def search
    unless params[:search].blank?
      @products = do_search(params, false)
      @result = @result.merge({ 'products' => make_products_list(@products['products']),
                                'products_count' => get_products_count
                              })
      @result['products_count']['search'] = @products['count']
    else
      @result['status'] = false
      @result['message'] = 'Improper search string'
    end

    render json: @result
  end

  def scan_per_product
    execute_scan_per_product

    render json: @result
  end

  def change_product_status
    #execute_groove_bulk_action(activity)
    execute_groove_bulk_action('status_update')
  end

  def delete_product
    #execute_groove_bulk_action(activity)
    execute_groove_bulk_action('delete')
  end

  def duplicate_product
    #execute_groove_bulk_action(activity)
    execute_groove_bulk_action('duplicate')
  end

  def show
    service_obj = ProductService::ProductInfo.new(params: params, current_user: current_user, result: @result)
    @result = service_obj.get_product_info

    render json: @result
  end

  def add_product_to_kit
    #@kit is coming from find_kit_product method of products concern
    @result = ProductKitSkus.app_product_to_kit(@kit, params, @result, current_user) if check_if_not_a_kit

    render json: @result
  end

  def remove_products_from_kit
    #@kit is coming from find_kit_product method of products concern
    @result = ProductKitSkus.remove_products_from_kit(@kit, params, @result, current_user) if check_if_not_a_kit

    render json: @result
  end

  def update
    @result = gp_products_module.update_product_attributes
    product_hash_scan_pack_v2(@params ? @params : params) if (params[:app] rescue @params[:app])
    render json: @result
  end

  #This method will genearte barcode pdf file and store it in S3 and return url of the file from S3.
  def generate_barcode_slip
    require 'wicked_pdf'
    general_settings = GeneralSetting.last
    @show_bin_locations = general_settings.try(:show_primary_bin_loc_in_barcodeslip)
    @show_sku_in_barcodeslip = general_settings.try(:show_sku_in_barcodeslip)
    @item = OrderItem.find(params[:item_id]) rescue nil
    @product = Product.find(params[:id])
    @barcode = params["barcode"]
    respond_to do |format|
      format.html
      format.pdf {
        render :pdf => "file_name",
               :template => "products/generate_barcode_slip.html.erb",
               :orientation => 'Portrait',
               :page_height => '1in',
               :page_width => '3in',
               :margin => {:top => '0', :bottom => '0', :left => '0', :right => '0'}
      }
    end
    # base_file_name = File.basename(pdf_path)
    # pdf_file = File.open(reader_file_path)
    # GroovS3.create_pdf(@tenant_name, base_file_name, pdf_file.read)
    # pdf_file.close
    # generate_barcode = ENV['S3_BASE_URL']+'/'+@tenant_name+'/pdf/'+base_file_name
    # render json: {url: generate_barcode}
  end

  def bulk_barcode_generation
    execute_groove_bulk_action('order_product_barcode_label')
  end

  def bulk_barcode_pdf
    require 'wicked_pdf'
    general_settings = GeneralSetting.last
    order_ids = params["ids"].split(",").reject { |c| c.empty? } rescue nil
    @show_bin_locations = general_settings.try(:show_primary_bin_loc_in_barcodeslip)
    @show_sku_in_barcodeslip = general_settings.try(:show_sku_in_barcodeslip)
    @order_items = params[:ids] == "all" ? (params[:status] == "all" ? Order.includes(order_items: [product: %i[product_skus product_barcodes product_inventory_warehousess]]).includes(:order_items).map(&:order_items).flatten : Order.where(status: params[:status]).includes(:order_items).map(&:order_items).flatten) : Order.includes(order_items: [product: %i[product_skus product_barcodes product_inventory_warehousess]]).where("id in (?)", order_ids).map(&:order_items).flatten
    respond_to do |format|
      format.html
      format.pdf {
        render :pdf => "file_name",
               :template => "products/bulk_barcode_pdf.html.erb",
               :orientation => 'Portrait',
               :page_height => '1in',
               :page_width => '3in',
               :margin => {:top => '0', :bottom => '0', :left => '0', :right => '0'}
      }
    end
  end

  def update_product_list
    params["current_user"] = current_user.name
    @result = Product.update_product_list(params, @result)
    Order.find(params[:order_id]).update_order_status rescue nil if params[:order_id].present?
    render json: @result
  end

  #This action will remove the entry for this product (the Alias) and the SKU of this new
  #product will be added to the list of skus for the existing product that the user is linking it to.
  #Any product can be turned into an alias, it doesn?t have to have the status of new, although most if the time it probably will.
  #The operation can not be undone.
  #If you had a situation where the newly imported product was actually the one you wanted to keep you could
  #find the original product and make it an alias of the new product...
  def set_alias
    product_aliasing.set_alias

    render json: @result
  end

  def add_image
    product = Product.find(params[:id])
    add_new_image(product)

    render json: @result
  end

  #input params[:id] gives product id params[:inv_wh_id] gives inventory warehouse id
  #params[:inventory_count] contains the inventory count from the recount
  #params[:method] this can contain two options: 'recount' or 'receive'
  #PUT request and it updates the available inventory if method is recount
  # or adds to the available inventory if method is receive if the product is
  #not associated with the inventory warehouse, then it automatically associates it and
  #sets the value.
  def adjust_available_inventory
    unless params[:id].nil? || params[:inv_wh_id].nil? || params[:method].nil?
      params["current_user"] = current_user.name
      result = ProductInventoryWarehouses.adjust_available_inventory(params, result)
    else
      @result['status'] &= false
      @result['error_messages'].push('Cannot recount inventory without product id and inventory_warehouse_id')
    end
    render json: @result
  end

  def generate_products_csv
    if current_user.can? 'create_backups'
      @result = generate_csv(@result)
    else
      @result['status'] = false
      @result['messages'].push('You do not have enough permissions to create backup csv')
    end
    @result = generate_error_csv(@result) unless @result['status']

    render json: @result
  end

  def generate_broken_image
    result = {};
    tenant = Apartment::Tenant.current
    export_product = ExportSsProductsCsv.new
    export_product.delay(priority: 95).export_broken_image(tenant, params)
    result["status"] = true
    render json: result
  end

  def fix_shopify_broken_images
    result = {};
    tenant = Apartment::Tenant.current
    export_product = ExportSsProductsCsv.new
    export_product.delay(priority: 95).fix_shopify_product_images(tenant, params)
    # export_product.fix_shopify_product_images(tenant, params)
    result["status"] = true
    render json: result
  end

  def cancel_shopify_product_imports
    result = { }
    StoreProductImport.destroy_all
    result["status"] = true
    render json: result
  end

  def update_intangibleness
    Product.update_action_intangibleness(params)

    render json: @result
  end

  def update_image
    @result['status'] = ProductImage.update_image(params)
    render json: @result
  end

  def sync_with
    @result['status'] = SyncOption.create_update_sync_option(params)
    render json: @result
  end

  def get_inventory_setting
    setting = InventoryReportsSetting.last
    setting = setting.blank? ? InventoryReportsSetting.create : setting
    @result["setting"] = JSON.parse(setting.to_json)
    @result["inventory_report_toggle"] = Tenant.find_by_name(Apartment::Tenant.current).inventory_report_toggle
    @result["products"] = {}
    reports = ProductInventoryReport.includes([:products]).all
    reports.each_with_index do |report, index|
    @result["products"][index] = {"id" => report.id, "name" => report.name,
                                  "no_of_items" => get_item_count(report),
                                  "scheduled" => report.scheduled, "type" => report.type,
                                  "selected_id" => report.products.map(&:id),
                                  "is_locked" => report.is_locked }
    end 
    render json: @result
  end

  def get_item_count(report)
    if report.name == "All_Products_Report"
      count = Product.count
    elsif report.name == "Active_Products_Report"
      count = Product.where(status: "active").count
    else
      count = report.products.count
    end
    count
  end

  def update_inventory_settings
    @result= {}
    setting = InventoryReportsSetting.last
    setting = setting.blank? ? InventoryReportsSetting.new : InventoryReportsSetting.last
    atrs = params["setting"].except("updated_at", "created_at", "id")
    setting.assign_attributes(atrs.permit!)
    setting.save
    @result["status"] = true
    render json: @result
  end

  def update_inventory_record
    data = params["data"]
    @result = update_inv_record(data, params)
    render json: @result
  end

  def remove_inventory_record
    ids = params["selected_ids"]
    inventory_reports = ProductInventoryReport.where("id in (?)", ids)
    if inventory_reports.present?
      inventory_reports.each { |report| report.products.destroy_all}
      inventory_reports.destroy_all 
    end
    @result["status"] = true
    render json: @result
  end

  def update_inventory_option
    product_inv_setting = InventoryReportsSetting.last
    begin
      product_inv_setting.report_days_option = params["option"]
      product_inv_setting.save
    rescue 
    end
    render json: @result
  end

  def generate_product_inventory_report
    generate_report(params["report_ids"])
    render json: @result
  end

  def update_generic
    image = ProductImage.find_by_id(params["id"])
    images = ProductImage.where(image: image.try(:image))
    images.update_all(placeholder: params["flag"])
    image = image.reload rescue image
    @result["placeholder"] = image.placeholder
    render json: @result
  end

  def find_inactive_product
    scan_pack_object = ScanPack::Base.new
    scan_pack_object.delay(priority: 95).finding_products(Apartment::Tenant.current)
    render json: @result
  end

  private
  def execute_groove_bulk_action(activity)
    GrooveBulkActions.execute_groove_bulk_action(activity, params, current_user)

    render json: @result
  end

  def product_hash_scan_pack_v2(params)
    product = Product.find_by_id(params[:basicinfo][:id]) rescue nil
    if product.is_kit? && product.kit_parsing != 'single'
      result = Hash.new
      result = OrderItem.new.build_basic_item(product).except('partially_scanned', 'updated_at', 'order_item_id', 'box_id')
      result['product_type'] =  product.kit_parsing
      result['child_items'] = []
      option_products_array = product.product_kit_skuss.map(&:option_product)
      option_products_array.each do |kit_product|
        child_item = {}
        product_kit_sku = ProductKitSkus.find_by(option_product_id: kit_product.id)
        option_product = option_products_array.find { |op| op.id == product_kit_sku.option_product_id }
        child_item = OrderItem.new.build_basic_item(kit_product).except('partially_scanned', 'updated_at', 'order_item_id', 'box_id')
        child_item['kit_packing_placement'] = product_kit_sku.packing_order
        child_item['kit_product_id'] = kit_product.id
        child_item["product_qty_in_kit"] = product_kit_sku.qty
        result['child_items'].push(child_item)
      end
      result['child_items'] = result['child_items'].sort_by { |hsh| hsh['kit_packing_placement'] }
      @result['scan_pack_product'] = result
    else
      @result['scan_pack_product'] = OrderItem.new.build_basic_item(product).except('partially_scanned', 'updated_at', 'order_item_id', 'box_id')
    end
  rescue => e
    on_demand_logger = Logger.new("#{Rails.root}/log/product_hash_scan_pack_v2.log")
    on_demand_logger.info("=========================================")
    log = { tenant: Apartment::Tenant.current, params: params, result: @result, error: e }
    on_demand_logger.info(log)
  end
end
